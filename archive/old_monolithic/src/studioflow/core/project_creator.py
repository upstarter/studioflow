"""
Project Creator - The main engine that creates projects
"""

from pathlib import Path
from typing import Optional, List, Dict, Any
from datetime import datetime
import subprocess
import json

from .config_system import ConfigManager
from .template_engine import TemplateEngine
from .storage_manager import StorageManager

class ProjectCreator:
    """Main class for creating video projects"""
    
    def __init__(self, config_manager: Optional[ConfigManager] = None):
        self.config = config_manager or ConfigManager()
        self.engine = TemplateEngine(self.config)
        self.storage = StorageManager(self.config)
    
    def create(self, name: str, template: str = 'minimal', 
              path: Optional[str] = None, additions: List[str] = None) -> Path:
        """Create a new project"""
        
        from .validators import ProjectValidator
        
        # Get template
        template_data = self.engine.get_template(template)
        if not template_data:
            # Fallback to minimal if template not found
            template_data = self.engine.get_template('minimal')
            template = 'minimal'
        
        # Determine final path
        if path:
            base_path = Path(path).expanduser()
        else:
            base_path = self.storage.get_project_path()
        
        project_path = base_path / self.engine._format_name(name)
        
        # Validate all parameters
        available_templates = list(self.engine.builtin_templates.keys())
        valid, error = ProjectValidator.validate_all(
            name, project_path, template, available_templates,
            additions, template_data.get('options', {})
        )
        
        if not valid:
            raise ValueError(f"Validation failed: {error}")
        
        # Add template name to data for processing
        template_data['template_name'] = template
        
        # Build options
        options = {
            'add': additions or [],
            'template_name': template
        }
        
        # Create the project
        project_path = self.engine.apply_template(
            template_data, name, base_path, options
        )
        
        # Setup storage links if multi-tier
        self.storage.setup_project_links(project_path, template_data)
        
        # Create a project info file
        self._create_project_info(project_path, name, template)
        
        # Create README
        self._create_readme(project_path, name, template)
        
        # Create health baseline if requested
        if options.get('health', True):
            self._create_health_baseline(project_path)
        
        # Initialize git repository if requested (after all files created)
        if options.get('git', True):
            self._init_git_repo(project_path)
        
        return project_path
    
    def _create_project_info(self, project_path: Path, name: str, template: str):
        """Create a .studioflow/project.yml file with project metadata"""
        
        studioflow_dir = project_path / '.studioflow'
        studioflow_dir.mkdir(parents=True, exist_ok=True)
        
        info = {
            'name': name,
            'template': template,
            'created': datetime.now().isoformat(),
            'version': '1.0.0',
            'storage_profile': self.storage.profile_name
        }
        
        import yaml
        info_file = studioflow_dir / 'project.yml'
        with open(info_file, 'w') as f:
            yaml.dump(info, f, default_flow_style=False)
    
    def _create_readme(self, project_path: Path, name: str, template: str):
        """Create a README.md with project information"""
        
        readme_content = f"""# {name}

## Project Information
- **Created**: {datetime.now().strftime('%B %d, %Y')}
- **Template**: {template}
- **Storage Profile**: {self.storage.profile_name}
- **StudioFlow Version**: 1.0.0

## Directory Structure
```
{self._generate_tree_structure(project_path)}
```

## Quick Start

1. **Add your footage**:
   - Place raw footage in `footage/` (or subdirectories)
   - Audio files go in `audio/`
   - Graphics and thumbnails in `graphics/`

2. **Start editing**:
   - Open your editing software
   - Import the project structure
   - Begin your creative work

3. **Export your content**:
   - Final videos to `exports/youtube/`
   - Vertical content to `exports/shorts/`
   - Thumbnails to `exports/thumbnail/`

## Project Health

Check project health status:
```bash
studioflow health {project_path}
```

Create a snapshot:
```bash
studioflow snapshot {project_path}
```

## Git Workflow

This project is git-enabled. Commit your changes:
```bash
git add .
git commit -m "Your message"
```

## Notes

Add your project-specific notes here.

---
*Generated by StudioFlow - Professional video project organization*
"""
        
        readme_file = project_path / 'README.md'
        readme_file.write_text(readme_content)
    
    def _generate_tree_structure(self, project_path: Path) -> str:
        """Generate a text tree structure of the project"""
        lines = []
        
        def add_dir(path: Path, prefix: str = "", is_last: bool = True):
            if path.name.startswith('.'):
                return
            
            connector = "‚îî‚îÄ‚îÄ " if is_last else "‚îú‚îÄ‚îÄ "
            lines.append(f"{prefix}{connector}{path.name}/")
            
            children = sorted([p for p in path.iterdir() if p.is_dir() and not p.name.startswith('.')])
            for i, child in enumerate(children):
                extension = "    " if is_last else "‚îÇ   "
                add_dir(child, prefix + extension, i == len(children) - 1)
        
        # Add top-level directories
        dirs = sorted([p for p in project_path.iterdir() if p.is_dir() and not p.name.startswith('.')])
        for i, dir_path in enumerate(dirs[:10]):  # Limit to first 10 for README
            add_dir(dir_path, "", i == len(dirs) - 1)
        
        if len(dirs) > 10:
            lines.append("‚îî‚îÄ‚îÄ ... (more directories)")
        
        return '\n'.join(lines) if lines else project_path.name + '/'
    
    def _init_git_repo(self, project_path: Path):
        """Initialize git repository in the project"""
        try:
            # Add .gitkeep files to empty directories
            for dir_path in project_path.rglob('*'):
                if dir_path.is_dir() and not any(dir_path.iterdir()):
                    gitkeep = dir_path / '.gitkeep'
                    gitkeep.touch()
            
            # Initialize git repo
            subprocess.run(['git', 'init'], cwd=project_path, 
                         capture_output=True, check=True)
            
            # Create .gitignore
            gitignore_content = """# StudioFlow project gitignore
*.cache
*.tmp
.DS_Store
Thumbs.db
*.braw
*.r3d
*.arri
# Proxy files are regeneratable
01_PROXIES/
# Renders are regeneratable  
08_RENDERS/
# Cache directories
.cache/
cache/
# DaVinci Resolve
*.drp.bak
CacheClip/
"""
            gitignore_file = project_path / '.gitignore'
            gitignore_file.write_text(gitignore_content)
            
            # Initial commit
            subprocess.run(['git', 'add', '.'], cwd=project_path, 
                         capture_output=True, check=True)
            subprocess.run(['git', 'commit', '-m', 'Initial project structure'], 
                         cwd=project_path, capture_output=True, check=True)
        except subprocess.CalledProcessError:
            # Git not available or failed, skip silently
            pass
    
    def _create_health_baseline(self, project_path: Path):
        """Create initial health monitoring baseline"""
        health_dir = project_path / '.studioflow' / 'health'
        health_dir.mkdir(parents=True, exist_ok=True)
        
        baseline = {
            'created': datetime.now().isoformat(),
            'directories': {},
            'total_size': 0,
            'file_count': 0
        }
        
        # Count files and sizes
        for item in project_path.rglob('*'):
            if item.is_file() and '.git' not in str(item):
                baseline['file_count'] += 1
                baseline['total_size'] += item.stat().st_size
            elif item.is_dir() and '.git' not in str(item):
                rel_path = str(item.relative_to(project_path))
                baseline['directories'][rel_path] = {
                    'exists': True,
                    'file_count': len(list(item.glob('*')))
                }
        
        # Save baseline
        baseline_file = health_dir / 'baseline.json'
        with open(baseline_file, 'w') as f:
            json.dump(baseline, f, indent=2)
    
    def show_structure(self, name: str, template: str, 
                       path: Optional[str], additions: List[str]):
        """Show what would be created (dry run)"""
        
        from rich.tree import Tree
        from rich.console import Console
        from .youtube_optimizer import YouTubeOptimizer
        
        console = Console()
        
        # Get template
        template_data = self.engine.get_template(template) or self.engine.get_template('minimal')
        
        # Format name
        formatted_name = self.engine._format_name(name)
        
        # Build tree
        tree = Tree(f"üìÅ {formatted_name}")
        
        # Check if YouTube template with optimizer
        if 'youtube' in template.lower():
            optimizer = YouTubeOptimizer()
            structure = optimizer.build_structure(name, {'add': additions or []})
            dirs = structure['directories']
            files = structure.get('files', template_data.get('files', []))
        else:
            dirs = template_data.get('directories', [])
            files = template_data.get('files', [])
            
            # Add optional directories
            if additions:
                for add in additions:
                    if add in template_data.get('options', {}):
                        for opt_dir in template_data['options'][add]:
                            dirs.append(opt_dir)
        
        # Add directories to tree
        for dir_name in dirs:
            tree.add(f"üìÅ {dir_name}")
        
        # Add files to tree
        for file_spec in files:
            if isinstance(file_spec, dict):
                tree.add(f"üìÑ {file_spec.get('path', file_spec.get('name', 'unknown'))}")
            else:
                tree.add(f"üìÑ {file_spec}")
        
        tree.add("üìÑ .studioflow/project.yml (metadata)")
        
        console.print(tree)
        
        # Show location
        if path:
            base_path = Path(path).expanduser()
        else:
            base_path = self.storage.get_project_path()
        
        full_path = base_path / formatted_name
        console.print(f"\nWould create at: [cyan]{full_path}[/cyan]")