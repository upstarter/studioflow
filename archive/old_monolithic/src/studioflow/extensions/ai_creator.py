"""
StudioFlow AI Creator Extension
Adds Creator AI Studio capabilities to StudioFlow while maintaining its architecture
"""

import os
import json
import yaml
import shutil
from pathlib import Path
from datetime import datetime
from typing import Dict, Optional, Any
import subprocess

class AICreatorExtension:
    """
    Extension for StudioFlow that adds AI Creator Studio features
    Designed to work with existing StudioFlow generator
    """

    def __init__(self, config_path: str = "studioflow_ai_creator_template.yml"):
        """Load configuration from YAML"""
        with open(config_path, 'r') as f:
            self.config = yaml.safe_load(f)

        # Parse storage tiers from config
        self.storage = self._parse_storage_config()

        # Load template config
        self.template = self.config.get('ai_creator', {})

    def _parse_storage_config(self) -> Dict[str, Path]:
        """Parse storage configuration, use defaults if not specified"""
        storage = {}
        storage_config = self.config.get('storage', {}).get('tiers', {})

        # Use config paths or fallback to defaults
        storage['ingest'] = Path(storage_config.get('ingest', {}).get('path', '/mnt/ingest'))
        storage['active'] = Path(storage_config.get('active', {}).get('path', '/mnt/resolve/Projects'))
        storage['render'] = Path(storage_config.get('render', {}).get('path', '/mnt/render'))
        storage['library'] = Path(storage_config.get('library', {}).get('path', '/mnt/library'))
        storage['archive'] = Path(storage_config.get('archive', {}).get('path', '/mnt/archive'))

        return storage

    def prepare_for_resolve(self, project_path: Path) -> Dict[str, Any]:
        """
        Prepare project for immediate DaVinci Resolve import
        Returns Resolve configuration for the project
        """
        resolve_config = self.template.get('resolve', {})

        # Create Resolve project file with settings
        resolve_settings = {
            'project_name': project_path.name,
            'created': datetime.now().isoformat(),
            'timeline': {
                'resolution': resolve_config.get('timeline_resolution', '3840x2160'),
                'fps': resolve_config.get('timeline_fps', 24),
                'color_space': 'Rec.709 Gamma 2.4'
            },
            'media_pool': {
                'bins': resolve_config.get('bins', [])
            },
            'proxy': {
                'enabled': resolve_config.get('optimized_media', True),
                'resolution': resolve_config.get('proxy_resolution', '1920x1080')
            },
            'export_presets': resolve_config.get('export_presets', []),
            'import_paths': []
        }

        # Map actual folder paths to Resolve bins
        for bin_config in resolve_settings['media_pool']['bins']:
            bin_path = project_path / bin_config['path']
            if bin_path.exists():
                resolve_settings['import_paths'].append({
                    'name': bin_config['name'],
                    'path': str(bin_path),
                    'exists': True
                })

        # Save Resolve configuration
        resolve_file = project_path / '05_EDITING' / 'resolve_config.json'
        resolve_file.parent.mkdir(parents=True, exist_ok=True)
        resolve_file.write_text(json.dumps(resolve_settings, indent=2))

        # Create Resolve import script
        self._create_resolve_import_script(project_path, resolve_settings)

        return resolve_settings

    def _create_resolve_import_script(self, project_path: Path, settings: Dict):
        """Create a Python script for Resolve's Script API"""
        script_content = f'''#!/usr/bin/env python3
"""
DaVinci Resolve Import Script
Auto-generated by StudioFlow AI Creator
Project: {project_path.name}
"""

# This script uses DaVinci Resolve's Python API
# Run from: Workspace > Scripts > Run

import DaVinciResolveScript as dvr

def setup_project():
    resolve = dvr.scriptapp("Resolve")
    if not resolve:
        print("Please run this from within DaVinci Resolve")
        return

    # Get project manager
    pm = resolve.GetProjectManager()

    # Create new project
    project_name = "{project_path.name}"
    project = pm.CreateProject(project_name)

    if not project:
        print(f"Project {{project_name}} may already exist")
        project = pm.LoadProject(project_name)

    # Set project settings
    project.SetSetting("timelineResolutionWidth", "{settings['timeline']['resolution'].split('x')[0]}")
    project.SetSetting("timelineResolutionHeight", "{settings['timeline']['resolution'].split('x')[1]}")
    project.SetSetting("timelineFrameRate", "{settings['timeline']['fps']}")

    # Get media pool
    mp = project.GetMediaPool()

    # Create bins and import media
    root = mp.GetRootFolder()

    # Create bin structure
    bins = {json.dumps(settings['media_pool']['bins'], indent=4)}

    for bin_info in bins:
        bin_folder = mp.AddSubFolder(root, bin_info['name'])

        # Import media if path exists
        import_path = "{str(project_path)}" + "/" + bin_info['path']
        import os
        if os.path.exists(import_path):
            mp.SetCurrentFolder(bin_folder)
            mp.ImportMedia(import_path)

    print(f"Project {{project_name}} setup complete!")
    print("Next steps:")
    print("1. Generate optimized media (Playback > Generate Optimized Media)")
    print("2. Create your timeline")
    print("3. Begin editing!")

if __name__ == "__main__":
    setup_project()
'''

        script_file = project_path / '05_EDITING' / 'resolve_import.py'
        script_file.write_text(script_content)
        script_file.chmod(0o755)

    def create_comparison_scoreboard(
        self,
        project_path: Path,
        tool1: str,
        tool2: str,
        criteria: Optional[Dict] = None
    ) -> Path:
        """Create scoreboard data for AI tool comparisons"""
        scoreboard_dir = project_path / '00_PLANNING' / 'SCOREBOARD'
        scoreboard_dir.mkdir(parents=True, exist_ok=True)

        # Use template or custom criteria
        if not criteria:
            criteria = {
                'speed': {'tool_1': 0, 'tool_2': 0, 'weight': 20},
                'quality': {'tool_1': 0, 'tool_2': 0, 'weight': 30},
                'cost': {'tool_1': 0, 'tool_2': 0, 'weight': 20},
                'ease': {'tool_1': 0, 'tool_2': 0, 'weight': 15},
                'fun': {'tool_1': 0, 'tool_2': 0, 'weight': 15}
            }

        scoreboard_data = {
            'comparison': {
                'tool_1': tool1,
                'tool_2': tool2,
                'date': datetime.now().isoformat(),
                'criteria': criteria,
                'verdict': {
                    'winner': '',
                    'summary': '',
                    'key_differences': []
                }
            },
            'metadata': {
                'created': datetime.now().isoformat(),
                'project': project_path.name
            }
        }

        scoreboard_file = scoreboard_dir / 'comparison.json'
        scoreboard_file.write_text(json.dumps(scoreboard_data, indent=2))

        return scoreboard_file

    def generate_seo_variants(
        self,
        project_path: Path,
        base_title: str,
        keywords: list = None
    ) -> Path:
        """Generate SEO title/description variants for testing"""
        meta_dir = project_path / '07_META' / 'SEO_VARIANTS'
        meta_dir.mkdir(parents=True, exist_ok=True)

        # Generate title variants
        title_variants = [
            base_title,
            f"{base_title} - Shocking Results!",
            f"{base_title} (2025 Comparison)",
            f"{base_title} | Which is Better?",
            f"I Tested {base_title} - Here's What Happened"
        ]

        # Generate descriptions
        descriptions = {
            'short': f"Comparing the latest AI tools for creators. {base_title}",
            'medium': f"In-depth comparison and testing of AI tools. {base_title}. "
                     f"Real-world examples, pricing analysis, and recommendations.",
            'long': f"Complete guide to choosing the right AI tool for your creative workflow. "
                   f"{base_title}. Including speed tests, quality comparisons, pricing breakdowns, "
                   f"and real project examples. Perfect for content creators, developers, and designers."
        }

        # Generate tags
        tags = keywords or ['AI tools', 'comparison', '2025', 'creator tools']

        seo_data = {
            'title_variants': title_variants,
            'descriptions': descriptions,
            'tags': tags,
            'metadata': {
                'created': datetime.now().isoformat(),
                'base_title': base_title,
                'a_b_test': {
                    'enabled': True,
                    'variants_to_test': 3
                }
            }
        }

        seo_file = meta_dir / 'seo_variants.json'
        seo_file.write_text(json.dumps(seo_data, indent=2))

        return seo_file

    def link_shared_assets(self, project_path: Path):
        """Create symlinks to shared library assets"""
        assets_dir = project_path / '08_ASSETS'
        assets_dir.mkdir(parents=True, exist_ok=True)

        # Get shared asset configuration
        shared_config = self.template.get('smart_features', {}).get('shared_assets', {})

        if not shared_config.get('enabled', True):
            return

        library_path = self.storage['library']

        # Create symlinks to library resources
        asset_links = shared_config.get('assets', [])

        for asset in asset_links:
            source = library_path / asset['source']
            target = project_path / asset['target']

            if source.exists() and not target.exists():
                target.parent.mkdir(parents=True, exist_ok=True)
                target.symlink_to(source)
                print(f"Linked: {asset['source']} -> {asset['target']}")

    def setup_ingest_watch(self, project_path: Path) -> Path:
        """Setup auto-ingest from camera cards"""
        ingest_script = project_path / '.studioflow' / 'ingest_watch.sh'
        ingest_script.parent.mkdir(parents=True, exist_ok=True)

        # Create watch script
        script_content = f'''#!/bin/bash
# Auto-ingest watch script for {project_path.name}

PROJECT_PATH="{project_path}"
INGEST_PATH="{self.storage['ingest']}"

# Watch for new media
echo "Watching for new media in $INGEST_PATH"

# Function to process new files
process_media() {{
    local file="$1"
    local ext="${{file##*.}}"

    case "$ext" in
        mp4|mov|mxf)
            # Video files
            if [[ "$file" == *"C0"* ]]; then
                # Sony FX30
                cp "$file" "$PROJECT_PATH/01_RAW/FX30/"
            elif [[ "$file" == *"DSC"* ]]; then
                # Sony ZV-E10
                cp "$file" "$PROJECT_PATH/01_RAW/ZV_E10/"
            else
                cp "$file" "$PROJECT_PATH/01_RAW/"
            fi
            ;;
        wav|mp3|aif)
            # Audio files
            cp "$file" "$PROJECT_PATH/01_RAW/AUDIO/"
            ;;
        *)
            echo "Unknown file type: $file"
            ;;
    esac

    echo "Processed: $file"
}}

# Monitor ingest folder
inotifywait -m "$INGEST_PATH" -e create -e moved_to |
while read dir action file; do
    echo "New file detected: $file"
    process_media "$INGEST_PATH/$file"
done
'''

        ingest_script.write_text(script_content)
        ingest_script.chmod(0o755)

        return ingest_script

    def quick_project(
        self,
        name: str,
        project_type: str = "ai_battle",
        tools: list = None
    ) -> Path:
        """
        Quick project creation with everything ready for Resolve
        This integrates with existing StudioFlow
        """

        # Generate project path
        date_str = datetime.now().strftime('%Y-%m-%d')
        slug = name.lower().replace(' ', '_').replace('-', '_')
        project_path = self.storage['active'] / f"{date_str}_{slug}"

        # Create base structure using template
        self._create_from_template(project_path, project_type)

        # Prepare for Resolve
        resolve_config = self.prepare_for_resolve(project_path)

        # Create comparison scoreboard if applicable
        if project_type == "ai_battle" and tools and len(tools) >= 2:
            self.create_comparison_scoreboard(project_path, tools[0], tools[1])

        # Generate SEO variants
        self.generate_seo_variants(project_path, name, tools)

        # Link shared assets
        self.link_shared_assets(project_path)

        # Setup ingest watch
        self.setup_ingest_watch(project_path)

        print(f"âœ… Project created: {project_path}")
        print(f"ðŸ“ Ready for Resolve import")
        print(f"ðŸŽ¬ Import script: {project_path}/05_EDITING/resolve_import.py")
        print(f"ðŸ“Š Storage: {self._get_storage_status()}")

        return project_path

    def _create_from_template(self, project_path: Path, template_type: str):
        """Create directory structure from template"""
        # Get template configuration
        template = self.config.get('workflows', {}).get(template_type, self.template)

        # Create directories
        for directory in template.get('directories', []):
            dir_path = project_path / directory
            dir_path.mkdir(parents=True, exist_ok=True)

        # Create subdirectories
        subdirs = template.get('subdirs', {})
        for parent, children in subdirs.items():
            parent_path = project_path / parent
            parent_path.mkdir(parents=True, exist_ok=True)

            for child in children:
                if '/' in child:
                    # Handle nested paths
                    (parent_path / child).mkdir(parents=True, exist_ok=True)
                else:
                    (parent_path / child).mkdir(exist_ok=True)

    def _get_storage_status(self) -> str:
        """Get storage tier status"""
        status = []
        for name, path in self.storage.items():
            if path.exists():
                usage = shutil.disk_usage(path)
                free_gb = usage.free / (1024**3)
                status.append(f"{name}: {free_gb:.1f}GB free")
        return " | ".join(status)


# CLI wrapper for integration with StudioFlow
def main():
    import argparse

    parser = argparse.ArgumentParser(description='StudioFlow AI Creator Extension')
    parser.add_argument('name', help='Project name')
    parser.add_argument('--type', default='ai_battle',
                       choices=['ai_battle', 'ai_tutorial', 'ai_review'],
                       help='Project type')
    parser.add_argument('--tools', nargs='+', help='AI tools to compare')
    parser.add_argument('--config', default='studioflow_ai_creator_template.yml',
                       help='Configuration file path')

    args = parser.parse_args()

    # Create extension
    extension = AICreatorExtension(args.config)

    # Create project
    project_path = extension.quick_project(
        name=args.name,
        project_type=args.type,
        tools=args.tools
    )

    print(f"\nNext steps:")
    print("1. Open DaVinci Resolve")
    print(f"2. Run import script: {project_path}/05_EDITING/resolve_import.py")
    print("3. Start editing!")


if __name__ == "__main__":
    main()