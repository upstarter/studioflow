#!/usr/bin/env python3
"""
sf-resolve-orchestrator - Intelligent Resolve project orchestration
Handles first import, subsequent imports, smart bins, timeline management
"""

import sys
import os
import json
import subprocess
from pathlib import Path
from datetime import datetime, timedelta
import hashlib

sys.path.insert(0, '/mnt/projects/studioflow')
from sfcore import JsonStream

class ResolveOrchestrator:
    def __init__(self):
        self.json = JsonStream()

    def generate_resolve_script(self, project_path, session_num=None):
        """Generate intelligent Resolve setup based on import session"""

        metadata_file = project_path / ".studioflow" / "metadata.json"
        with open(metadata_file) as f:
            metadata = json.load(f)

        sessions = metadata.get("sessions", [])

        # Auto-detect session number if not provided
        if session_num is None:
            session_num = len(sessions)

        # Check if Resolve project already exists
        resolve_project_exists = (project_path / ".studioflow" / "resolve" / "project_created.flag").exists()
        is_first_import = not resolve_project_exists

        script = f'''#!/usr/bin/env python
# SF Resolve Orchestrator - Session {session_num}
# Generated: {datetime.now().isoformat()}

import DaVinciResolveScript as dvr
import os
import json

resolve = dvr.scriptapp("Resolve")
pm = resolve.GetProjectManager()

# Project name based on StudioFlow project
project_name = "{project_path.name}"
existing_project = pm.GetProjectByName(project_name)

if {str(is_first_import).lower()}:
    # ========== FIRST IMPORT - COMPLETE SETUP ==========
    print("ðŸŽ¬ First import detected - Creating new Resolve project with optimal YouTube settings...")

    project = pm.CreateProject(project_name)

    # Force 4K for YouTube VP9/AV1
    project.SetSetting("timelineResolutionWidth", "3840")
    project.SetSetting("timelineResolutionHeight", "2160")
    project.SetSetting("timelineFrameRate", "29.97")

    # Color management for FX30/ZV-E10 S-Cinetone
    project.SetSetting("colorScienceMode", "davinciYRGBColorManaged")
    project.SetSetting("colorSpaceInput", "Rec.709")
    project.SetSetting("colorSpaceTimeline", "Rec.709")
    project.SetSetting("colorSpaceOutput", "Rec.709")
    project.SetSetting("timelineWorkingLuminance", "100")

    # 10-bit processing
    project.SetSetting("videoBitDepth", "10")

    mp = project.GetMediaPool()
    root = mp.GetRootFolder()

    # ========== CREATE INTELLIGENT BIN STRUCTURE ==========

    bins = {{}}

    # Main organizational bins
    footage_bin = mp.AddSubFolder(root, "01_FOOTAGE")
    audio_bin = mp.AddSubFolder(root, "02_AUDIO")
    graphics_bin = mp.AddSubFolder(root, "03_GRAPHICS")
    timelines_bin = mp.AddSubFolder(root, "04_TIMELINES")
    compound_bin = mp.AddSubFolder(root, "05_COMPOUND_CLIPS")

    # Camera-specific bins
    bins['fx30'] = mp.AddSubFolder(footage_bin, "A_CAM_FX30")
    bins['zve10'] = mp.AddSubFolder(footage_bin, "B_CAM_ZVE10")
    bins['screen'] = mp.AddSubFolder(footage_bin, "SCREEN_CAPTURE")
    bins['multicam'] = mp.AddSubFolder(footage_bin, "MULTICAM")

    # Content-based bins
    bins['a_roll'] = mp.AddSubFolder(footage_bin, "A_ROLL_TALKING")
    bins['b_roll'] = mp.AddSubFolder(footage_bin, "B_ROLL_CUTAWAY")
    bins['hero'] = mp.AddSubFolder(footage_bin, "HERO_SHOTS")

    # Audio organization
    bins['dialogue'] = mp.AddSubFolder(audio_bin, "DIALOGUE")
    bins['music'] = mp.AddSubFolder(audio_bin, "MUSIC")
    bins['sfx'] = mp.AddSubFolder(audio_bin, "SFX")
    bins['voiceover'] = mp.AddSubFolder(audio_bin, "VOICEOVER")

    # Graphics
    bins['titles'] = mp.AddSubFolder(graphics_bin, "TITLES")
    bins['overlays'] = mp.AddSubFolder(graphics_bin, "OVERLAYS")
    bins['thumbnails'] = mp.AddSubFolder(graphics_bin, "THUMBNAILS")

    # Timelines
    bins['rough'] = mp.AddSubFolder(timelines_bin, "ROUGH_CUTS")
    bins['fine'] = mp.AddSubFolder(timelines_bin, "FINE_CUTS")
    bins['final'] = mp.AddSubFolder(timelines_bin, "FINAL")
    bins['versions'] = mp.AddSubFolder(timelines_bin, "VERSIONS")

    # ========== CREATE SMART BINS ==========

    print("ðŸ”® Creating Smart Bins for automatic organization...")

    # Duration-based smart bins
    mp.AddSubFolder(root, "SMART: Long Takes (60s+)")
    mp.AddSubFolder(root, "SMART: Medium (10-60s)")
    mp.AddSubFolder(root, "SMART: Short (<10s)")

    # Date-based smart bins (for multi-day projects)
    mp.AddSubFolder(root, "SMART: Today's Footage")
    mp.AddSubFolder(root, "SMART: This Week")

    # Technical smart bins
    mp.AddSubFolder(root, "SMART: 4K Clips")
    mp.AddSubFolder(root, "SMART: 1080p Clips")
    mp.AddSubFolder(root, "SMART: Needs Color")
    mp.AddSubFolder(root, "SMART: Good Takes â­")

    # Usage smart bins
    mp.AddSubFolder(root, "SMART: Used in Timeline")
    mp.AddSubFolder(root, "SMART: Unused Clips")
    mp.AddSubFolder(root, "SMART: Marked for Review")

    # ========== CREATE MASTER TIMELINE ==========

    print("ðŸ“ Creating YouTube-optimized timeline structure...")

    mp.SetCurrentFolder(root)

    # Create main edit timeline
    timeline = mp.CreateEmptyTimeline("MAIN_EDIT_v001")

    if timeline:
        # Force 4K output
        timeline.SetSetting("timelineResolutionWidth", "3840")
        timeline.SetSetting("timelineResolutionHeight", "2160")
        timeline.SetSetting("timelineFrameRate", "29.97")

        # Set up video tracks with labels
        timeline.SetTrackName("video", 1, "A-ROLL MAIN")
        timeline.SetTrackName("video", 2, "B-ROLL CUTAWAY")
        timeline.SetTrackName("video", 3, "GRAPHICS LOWER")
        timeline.SetTrackName("video", 4, "TITLES UPPER")
        timeline.SetTrackName("video", 5, "COLOR/ADJUST")

        # Set up audio tracks
        timeline.SetTrackName("audio", 1, "DIALOGUE L")
        timeline.SetTrackName("audio", 2, "DIALOGUE R")
        timeline.SetTrackName("audio", 3, "MUSIC L")
        timeline.SetTrackName("audio", 4, "MUSIC R")
        timeline.SetTrackName("audio", 5, "SFX")
        timeline.SetTrackName("audio", 6, "ROOM TONE")

        # Add content structure markers
        markers = [
            (0, "Red", "ðŸŽ¯ HOOK", "0:00-0:03 - Critical 3 seconds"),
            (90, "Red", "ðŸ”¥ HOOK2", "0:03-0:20 - Extended hook"),
            (600, "Blue", "ðŸ“˜ INTRO", "0:20-0:45 - Set expectations"),
            (1350, "Green", "ðŸ’š MAIN", "0:45-7:00 - Core content"),
            (1800, "Yellow", "âš¡ INTERRUPT1", "1:00 - Pattern interrupt"),
            (3600, "Yellow", "âš¡ INTERRUPT2", "2:00 - Keep attention"),
            (5400, "Yellow", "âš¡ INTERRUPT3", "3:00 - Re-engage"),
            (7200, "Yellow", "âš¡ INTERRUPT4", "4:00 - Energy boost"),
            (12600, "Orange", "ðŸŽ PAYOFF", "7:00-8:00 - Deliver value"),
            (14400, "Red", "ðŸ‘ CTA", "8:00-8:30 - Subscribe/Like"),
            (15300, "Purple", "âž¡ï¸ ENDSCREEN", "8:30-9:00 - Next video")
        ]

        for frame, color, name, note in markers:
            timeline.AddMarker(frame, color, name, note, 1)

        # Create additional timeline templates
        mp.SetCurrentFolder(bins['rough'])
        mp.CreateEmptyTimeline("ASSEMBLY_RAW")

        mp.SetCurrentFolder(bins['versions'])
        mp.CreateEmptyTimeline("SHORT_60s_VERSION")
        mp.CreateEmptyTimeline("EXTENDED_15min_VERSION")

    print("âœ… First import setup complete!")

    # Mark that Resolve project has been created
    with open(r"{project_path / '.studioflow' / 'resolve' / 'project_created.flag'}", "w") as f:
        f.write(f"{{datetime.now().isoformat()}}")

else:
    # ========== SUBSEQUENT IMPORT - SMART INTEGRATION ==========

    if not existing_project:
        print("âš ï¸ Resolve project doesn't exist yet. Please run first import setup.")
        exit(1)

    pm.LoadProject(existing_project)
    project = pm.GetCurrentProject()
    print(f"ðŸ“‚ Session {{session_num}} - Loading existing project: {{project_name}}")

    mp = project.GetMediaPool()
    root = mp.GetRootFolder()

    # Rebuild bins dictionary by searching
    bins = {{}}
    for folder in mp.GetRootFolder().GetSubFolderList():
        name = folder.GetName()
        if "FOOTAGE" in name:
            for subfolder in folder.GetSubFolderList():
                sub_name = subfolder.GetName()
                if "FX30" in sub_name:
                    bins['fx30'] = subfolder
                elif "ZVE10" in sub_name:
                    bins['zve10'] = subfolder
                elif "A_ROLL" in sub_name:
                    bins['a_roll'] = subfolder
                elif "B_ROLL" in sub_name:
                    bins['b_roll'] = subfolder

    print(f"â™»ï¸ Session {session_num} - Smart integration mode")

# ========== IMPORT MEDIA FROM CURRENT SESSION ==========
'''

        # Add session-specific import logic
        if sessions and session_num <= len(sessions):
            current_session = sessions[session_num - 1]
            import_path = current_session.get('import_path', '')
            camera = current_session.get('camera', 'UNKNOWN')
            categories = current_session.get('categories', {})

            script += f'''
# Import Session {session_num} media
session_data = {json.dumps(current_session, indent=4)}
import_base = r"{import_path}"

print(f"ðŸ“¥ Importing Session {session_num}: {{session_data['clips']}} clips from {{session_data['camera']}}")

# Smart import based on content analysis
if os.path.exists(import_base):
    # Import by category with intelligent bin placement
'''

            # Add category-specific imports
            for category, count in categories.items():
                if count > 0:
                    script += f'''
    # Import {category} clips
    {category}_clips = []
    for file in os.listdir(os.path.join(import_base, "M4ROOT", "CLIP")):
        if file.endswith(".MP4"):
            # Add your clip detection logic here
            {category}_clips.append(os.path.join(import_base, "M4ROOT", "CLIP", file))

    if {category}_clips and bins.get('{category}'):
        mp.SetCurrentFolder(bins['{category}'])
        mp.ImportMedia({category}_clips)
        print(f"  âœ“ Imported {{len({category}_clips)}} {category} clips")
'''

        # Add timeline management
        script += '''

# ========== TIMELINE MANAGEMENT ==========

current_timeline = project.GetCurrentTimeline()

if not current_timeline:
    # Get main edit timeline
    for timeline in project.GetTimelineList():
        if "MAIN_EDIT" in timeline.GetName():
            project.SetCurrentTimeline(timeline)
            current_timeline = timeline
            break

if current_timeline:
    print(f"ðŸ“¹ Working timeline: {current_timeline.GetName()}")

    # Auto-add to timeline if rough cut
    if "ASSEMBLY" in current_timeline.GetName() or session_num == 1:
        print("ðŸŽ¬ Adding new clips to assembly timeline...")

        # Get imported clips
        new_clips = mp.GetCurrentFolder().GetClipList()

        for clip in new_clips:
            # Add A-roll to track 1, B-roll to track 2
            clip_name = clip.GetName()
            if "long_take" in clip_name.lower() or clip.GetMetadata("Duration") > 60:
                mp.AppendToTimeline(clip, trackIndex=1)
            else:
                mp.AppendToTimeline(clip, trackIndex=2)

# ========== MULTICAM SYNC ==========

if session_num > 1:
    print("ðŸŽ¥ Checking for multicam opportunities...")

    # Find overlapping clips from different cameras
    fx30_clips = bins.get('fx30', mp.GetRootFolder()).GetClipList()
    zve10_clips = bins.get('zve10', mp.GetRootFolder()).GetClipList()

    if fx30_clips and zve10_clips:
        print(f"  Found {len(fx30_clips)} FX30 and {len(zve10_clips)} ZV-E10 clips")

        # Create multicam clips based on timestamp overlap
        # This requires Resolve Studio's multicam features
        if bins.get('multicam'):
            mp.SetCurrentFolder(bins['multicam'])
            # Multicam sync would happen here

# ========== COLOR MANAGEMENT ==========

print("ðŸŽ¨ Applying base color for S-Cinetone...")

# Create a base grade for all new clips
new_clips = mp.GetCurrentFolder().GetClipList()
for clip in new_clips:
    # S-Cinetone needs minimal adjustment
    # +5% contrast, +8% saturation for YouTube
    clip.SetMetadata("ColorNotes", "S-Cinetone base grade needed")

# ========== SMART BIN UPDATES ==========

print("ðŸ”„ Updating Smart Bins...")

# Smart bins auto-update based on metadata
# but we can force a refresh
project.Save()

# ========== REPORTING ==========

print("\\n" + "="*50)
print("ðŸ“Š SESSION {session_num} IMPORT COMPLETE")
print("="*50)
print(f"âœ… Project: {project_name}")
print(f"ðŸ“¹ Timeline: {current_timeline.GetName() if current_timeline else 'None'}")
print(f"ðŸŽ¬ Total Sessions: {session_num}")
print(f"ðŸ“ New Clips: {session_data.get('clips', 0)}")
print(f"â±ï¸ Total Duration: {session_data.get('duration', 0):.1f} seconds")
print("\\nðŸŽ¯ Next Steps:")
print("  1. Review new clips in Smart Bins")
print("  2. Mark best takes with â­")
print("  3. Build rough cut on timeline")
print("  4. Apply YouTube optimization")
'''

        # Save script
        script_dir = project_path / ".studioflow" / "resolve" / "sessions"
        script_dir.mkdir(parents=True, exist_ok=True)

        script_path = script_dir / f"session_{session_num:03d}_import.py"
        script_path.write_text(script)

        return script_path

    def create_advanced_features_script(self, project_path):
        """Generate script for advanced Resolve features"""

        script = '''#!/usr/bin/env python
# Advanced Resolve Features for YouTube Optimization

import DaVinciResolveScript as dvr

resolve = dvr.scriptapp("Resolve")
project = resolve.GetCurrentProject()
mp = project.GetMediaPool()

# ========== ADVANCED SMART BINS ==========

print("ðŸ§  Setting up advanced Smart Bins...")

smart_bins_config = [
    {
        "name": "ðŸ”´ HERO SHOTS",
        "rules": [
            {"property": "Clip Name", "condition": "contains", "value": "HERO"},
            {"property": "Duration", "condition": ">", "value": "5"},
            {"property": "Flag", "condition": "is", "value": "Green"}
        ]
    },
    {
        "name": "ðŸŽ™ï¸ TALKING HEAD",
        "rules": [
            {"property": "Duration", "condition": ">", "value": "30"},
            {"property": "Scene", "condition": "contains", "value": "A-CAM"}
        ]
    },
    {
        "name": "âš¡ QUICK CUTS",
        "rules": [
            {"property": "Duration", "condition": "<", "value": "3"},
            {"property": "Duration", "condition": ">", "value": "0.5"}
        ]
    },
    {
        "name": "ðŸŽ¨ NEEDS COLOR",
        "rules": [
            {"property": "Color Notes", "condition": "contains", "value": "grade needed"}
        ]
    },
    {
        "name": "ðŸ“Š 4K MASTERS",
        "rules": [
            {"property": "Resolution", "condition": "is", "value": "3840x2160"}
        ]
    },
    {
        "name": "ðŸ“± VERTICAL READY",
        "rules": [
            {"property": "Aspect Ratio", "condition": "is", "value": "9:16"},
            {"property": "Resolution Height", "condition": ">", "value": "1920"}
        ]
    }
]

# Create smart bins with rules
for config in smart_bins_config:
    bin_name = config["name"]
    # Note: Actual Smart Bin API varies by Resolve version
    print(f"  Creating: {bin_name}")

# ========== POWER GRADES FOR YOUTUBE ==========

print("ðŸŽ¨ Creating YouTube-optimized Power Grades...")

# Base YouTube grade (slight contrast and saturation boost)
youtube_grade = {
    "name": "YouTube Optimized",
    "adjustments": {
        "lift": {"y": 0.0, "r": 0.0, "g": 0.0, "b": 0.002},
        "gamma": {"y": 1.0, "r": 1.0, "g": 1.0, "b": 1.0},
        "gain": {"y": 1.0, "r": 1.01, "g": 1.0, "b": 0.99},
        "contrast": 1.05,
        "saturation": 1.08,
        "midtone_detail": 0
    }
}

# Thumbnail grade (high contrast, high saturation)
thumbnail_grade = {
    "name": "Thumbnail Pop",
    "adjustments": {
        "contrast": 1.15,
        "saturation": 1.25,
        "highlights": 1.1,
        "shadows": 0.9,
        "vibrance": 1.2
    }
}

# ========== AUDIO PRESETS ==========

print("ðŸ”Š Setting up -14 LUFS audio presets...")

# Fairlight presets for YouTube
audio_presets = {
    "dialogue": {
        "eq": {"high_pass": 80, "presence_boost": 3500},
        "compressor": {"threshold": -18, "ratio": 3, "attack": 10, "release": 100},
        "target": -20  # Individual track target
    },
    "music": {
        "eq": {"low_shelf": -3, "high_shelf": -2},
        "compressor": {"threshold": -12, "ratio": 2, "attack": 5, "release": 50},
        "target": -23
    },
    "master": {
        "limiter": {"ceiling": -0.3, "release": 50},
        "loudness": {"target": -14.0, "max_peak": -1.0}
    }
}

# ========== OPTIMIZATION FLAGS ==========

print("ðŸš€ Setting up workflow optimization...")

# Create custom timeline markers for YouTube chapters
chapter_markers = [
    {"tc": "00:00:00", "name": "Introduction", "color": "Blue"},
    {"tc": "00:00:45", "name": "Main Topic", "color": "Green"},
    {"tc": "00:03:00", "name": "Deep Dive", "color": "Cyan"},
    {"tc": "00:05:00", "name": "Examples", "color": "Yellow"},
    {"tc": "00:07:00", "name": "Summary", "color": "Orange"},
    {"tc": "00:08:00", "name": "Call to Action", "color": "Red"}
]

timeline = project.GetCurrentTimeline()
if timeline:
    for marker in chapter_markers:
        # Convert timecode to frames
        fps = float(timeline.GetSetting("timelineFrameRate"))
        # Add chapter markers for YouTube

print("âœ… Advanced features configured!")
'''

        script_path = project_path / ".studioflow" / "resolve" / "advanced_features.py"
        script_path.parent.mkdir(parents=True, exist_ok=True)
        script_path.write_text(script)

        return script_path

    def create_workflow_automation(self, project_path):
        """Create complete workflow automation"""

        workflow = {
            "first_import": {
                "actions": [
                    "create_project",
                    "setup_bins",
                    "create_smart_bins",
                    "create_timelines",
                    "import_media",
                    "analyze_content",
                    "create_assembly"
                ],
                "timeline": "ASSEMBLY_RAW"
            },
            "subsequent_imports": {
                "actions": [
                    "detect_session",
                    "import_to_bins",
                    "sync_multicam",
                    "update_smart_bins",
                    "append_to_timeline",
                    "version_timeline"
                ],
                "timeline": "MAIN_EDIT_v{session:03d}"
            },
            "daily_tasks": {
                "review": [
                    "check_smart_bins",
                    "mark_best_takes",
                    "flag_issues"
                ],
                "edit": [
                    "rough_cut",
                    "fine_cut",
                    "color_grade",
                    "audio_mix"
                ],
                "export": [
                    "render_preview",
                    "render_master",
                    "render_platforms"
                ]
            }
        }

        workflow_file = project_path / ".studioflow" / "workflow.json"
        with open(workflow_file, "w") as f:
            json.dump(workflow, f, indent=2)

        return workflow

def main():
    orchestrator = ResolveOrchestrator()

    if len(sys.argv) < 2:
        print("sf-resolve-orchestrator - Intelligent Resolve automation")
        print("\nUsage:")
        print("  sf-resolve-orchestrator <project_path> [session_num]")
        print("\nExample:")
        print("  sf-resolve-orchestrator /mnt/studio/Projects/Episode1 1")
        return

    project_path = Path(sys.argv[1])
    session_num = int(sys.argv[2]) if len(sys.argv) > 2 else 1

    # Generate appropriate scripts
    print(f"ðŸŽ¬ Generating Resolve scripts for session {session_num}...")

    script = orchestrator.generate_resolve_script(project_path, session_num)
    print(f"âœ… Generated: {script}")

    if session_num == 1:
        advanced = orchestrator.create_advanced_features_script(project_path)
        print(f"âœ… Generated: {advanced}")

        workflow = orchestrator.create_workflow_automation(project_path)
        print(f"âœ… Created workflow: {project_path}/.studioflow/workflow.json")

    print("\nðŸ“‹ To use in Resolve:")
    print("  1. Open DaVinci Resolve")
    print("  2. Open Console (Workspace â†’ Console)")
    print("  3. Select Py3 tab")
    print(f"  4. Copy and paste from: {script}")
    print("  5. Press Enter to execute")

if __name__ == "__main__":
    main()